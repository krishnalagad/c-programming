                                ****** NOTES *****

1) defaulted & deleted member functions
    : you can explicitly specify what is enabled vs disabled

2) constructor delegation
    : transfer control from one constructor another of the same class to use "chaining of constructors" to fully construct an object. It can avoid duplicated initialization code.

3) explicit keyword
    : prevents a constructor with 1 "unknown/non-default" parameter to be used for an implicit type conversion.

4) Introduction to smart pointers
    : scope based resource management for handling pointer deallocation "smartly".

5) using keyword
    : creates an alternate name/alias for some type.

6) auto keyword
    : allows for inferring or deducing type of a variable based on initial value.

7) uniform initialization
    : one common syntactical way of initializing everything.

8) nullptr
    : replacement of NULL macro with a proper type (std::nullptr_t)

lvalues: values that are in the RAM (have a fixed location) aka have an adress
         lvalues have a name given by us

rvalues: temporary value (result of an expression or displacement).
          rvalues dont have a fixed address (We cant go to their location in RAM and find value )

Intention:
 
1) Both Accepted:
    a) Lvalues accepted by copy, rvalues must be assigned e.g Magic(int n1);
    b) Lvalue by reference, rvaules must be assigned e.g: Magic(const int& n1)
 
2) Only value by reference: 
        e.g: Magic(int& n1)
 
3) Only rvalues by assignment 
        e.g: Magic(int&& n1)

- For every STL container, actual data is stored in heap, only start and end ptr are stored on stack
  regardless of the size.

- Inheritance:  To perform generalization or specialization in code we can use inheritance.
                To provide logic to the subtypes or to make universal logic for all subtypes.
- Polymorphism: Doing a action in a code more than one way is Polymorphism.
                Object init (Constructor overloading), cal taxes differently (Function overloading)
- Association:  Alpha uses functionalities from Beta
                                OR
                Beta uses functionalities from Alpha
- Composition:  Alpha is instantiated by using one or more instances of Beta. Instance of alpha 
                controls the life of instance/s of Beta
                                                OR
                Beta is instantiated by using one or more instances of Alpha. Instance of Beta 
                controls the life of instance/s of Alpha
- Aggregation:  Alpha is instantiated by using one or more instances of Beta. Instance of alpha 
                does not control the lifetime of instance/s of Beta
                                                OR
                Beta is instantiated by using one or more instances of Alpha. Instance of Beta does 
                not control the lifetime of instance/s of Alpha

For every data member, following things must be considered
 
    1) Is it supposed to be mutable or immutable?
        - Does it need to auto-increment based on previous value ?
    2) Should be accepted by value, by lvalue reference or rvalue reference or both?
    3) Is it stack allocated or heap allocated? (or maybe both partially?)
    4) Does it need to be smartly managed? (applicable only for heap allocated members)
    5) Does the data member need to have a non-null state at the time of instantiation of the object

    - Every function has a type (its signature)
    - function can be passed as a parameter to other functions
    - functions can be returned from other functions
    - functions address can be captured in a variable.
    - functions can be stored in containers
Tools: 
    - objdump
    - cMake
    - gdb

In capture clause
        [&] means all variables in enclosing function are captured by reference       
        [=] means all variables in enclosing function are captured by value 
        [&n1] means only n1 variable is captured by reference       
        [n1] means only nl is captured by value       
        [n1, &a] : n1 by value and a by reference

If we accept var by value in capture clause of lambda We cant change the value of 
        var in the lambda body, because it becomes const in lambda body to achieve functional
        programming.

        If we still want to make changes then we can make laambda function as mutable   

SOC (System on Chip)
    - core : one available working node in the microprocessor
    - thread : set of instructions to be executed

OS by Galvin
Computer Architecture by Hwang
Computer Networking by tanenbaum
Effective Modern C++ by Scott Mears
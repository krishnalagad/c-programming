                                ****** NOTES *****

1) defaulted & deleted member functions
    : you can explicitly specify what is enabled vs disabled

2) constructor delegation
    : transfer control from one constructor another of the same class to use "chaining of constructors" to fully construct an object. It can avoid duplicated initialization code.

3) explicit keyword
    : prevents a constructor with 1 "unknown/non-default" parameter to be used for an implicit type conversion.

4) Introduction to smart pointers
    : scope based resource management for handling pointer deallocation "smartly".

5) using keyword
    : creates an alternate name/alias for some type.

6) auto keyword
    : allows for inferring or deducing type of a variable based on initial value.

7) uniform initialization
    : one common syntactical way of initializing everything.

8) nullptr
    : replacement of NULL macro with a proper type (std::nullptr_t)

lvalues: values that are in the RAM (have a fixed location) aka have an adress
         lvalues have a name given by us

rvalues: temporary value (result of an expression or displacement).
          rvalues dont have a fixed address (We cant go to their location in RAM and find value )

Intention:
 
1) Both Accepted:
    a) Lvalues accepted by copy, rvalues must be assigned e.g Magic(int n1);
    b) Lvalue by reference, rvaules must be assigned e.g: Magic(const int& n1)
 
2) Only value by reference: 
        e.g: Magic(int& n1)
 
3) Only rvalues by assignment 
        e.g: Magic(int&& n1)

- For every STL container, actual data is stored in heap, only start and end ptr are stored on stack
  regardless of the size.

- Inheritance:  To perform generalization or specialization in code we can use inheritance.
                To provide logic to the subtypes or to make universal logic for all subtypes.
- Polymorphism: Doing a action in a code more than one way is Polymorphism.
                Object init (Constructor overloading), cal taxes differently (Function overloading)
- Association:  Alpha uses functionalities from Beta
                                OR
                Beta uses functionalities from Alpha
- Composition:  Alpha is instantiated by using one or more instances of Beta. Instance of alpha 
                controls the life of instance/s of Beta
                                                OR
                Beta is instantiated by using one or more instances of Alpha. Instance of Beta 
                controls the life of instance/s of Alpha
- Aggregation:  Alpha is instantiated by using one or more instances of Beta. Instance of alpha 
                does not control the lifetime of instance/s of Beta
                                                OR
                Beta is instantiated by using one or more instances of Alpha. Instance of Beta does 
                not control the lifetime of instance/s of Alpha

OS by Galvin
Computer Architecture by Hwang
Computer Networking by tanenbaum
Effective Modern C++ by Scott Mears